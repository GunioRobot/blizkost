/*
Copyright (C) 2009, Jonathan Worthington and friends
$Id$

=head1 NAME

src/pmc/p5scalar.pmc - pmc for Perl 5 array type

=head1 DESCRIPTION

These are the vtable functions for the P5Scalar class.

=cut

*/

/* Various Perl 5 headers that we need. */
#undef __attribute__
#undef __attribute__noreturn__
#undef __attribute__deprecated__
#define __attribute__(x) /* */
#include <EXTERN.h>
#include <perl.h>

/* Plus need to know about the interpreter and invocation PMCs. */
#include "pmc_p5interpreter.h"
#include "pmc_p5invocation.h"

pmclass P5Scalar group blizkost_group dynpmc {
    ATTR PMC       *p5i;
    ATTR struct sv *sv;    

/*

=item C<void init()>

Set up P5Scalar PMC.

=cut

*/

    VTABLE void init() {
        /* Set up the underlying structure. */
        PMC_data(SELF) = mem_allocate_zeroed_typed(Parrot_P5Scalar_attributes);
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);
    }

/*

=item C<void mark()>

Mark GC-ables.

=cut

*/
    VTABLE void mark() {
        if (PMC_data(SELF)) {
            PMC *p5i;
            GETATTR_P5Scalar_p5i(interp, SELF, p5i);
            if (p5i)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)p5i);
        }
    }


/*

=item C<void destroy()>

Decrement reference count of held SV.

=cut

*/
    VTABLE void destroy() {
        if (PMC_data(SELF)) {
            PMC             *p5i;
            PerlInterpreter *my_perl;
            struct sv       *sv;
            GETATTR_P5Scalar_p5i(interp, SELF, p5i);
            GETATTR_P5Interpreter_my_perl(interp, p5i, my_perl);
            GETATTR_P5Scalar_sv(interp, SELF, sv);
            SvREFCNT_dec(sv);
            mem_sys_free(PMC_data(SELF));
            PMC_data(SELF) = NULL;
        }
    }


/*

=item C<INTVAL get_bool()>

Returns the boolean value of the SV.

=cut

*/

    VTABLE INTVAL get_bool() {
        return SELF.get_integer() ? 1 : 0;
    }

/*

=item C<INTVAL get_integer()>

Returns the integer value of the SV.

=cut

*/

    VTABLE INTVAL get_integer() {
        PMC             *p5i;
        PerlInterpreter *my_perl;
        struct sv       *sv;
        GETATTR_P5Scalar_p5i(interp, SELF, p5i);
        GETATTR_P5Interpreter_my_perl(interp, p5i, my_perl);
        GETATTR_P5Scalar_sv(interp, SELF, sv);
        return SvIV(sv);
    }

/*

=item C<NUMVAL get_integer()>

Returns the number value of the SV.

=cut

*/

    VTABLE FLOATVAL get_number() {
        PMC             *p5i;
        PerlInterpreter *my_perl;
        struct sv       *sv;
        GETATTR_P5Scalar_p5i(interp, SELF, p5i);
        GETATTR_P5Interpreter_my_perl(interp, p5i, my_perl);
        GETATTR_P5Scalar_sv(interp, SELF, sv);
        return SvNV(sv);
    }

/*

=item C<STRING *get_string()>

Returns the string value of the SV.

=cut

*/
    VTABLE STRING *get_string() {
        PMC             *p5i;
        PerlInterpreter *my_perl;
        struct sv       *sv;
        char            *perl5_str;
        GETATTR_P5Scalar_p5i(interp, SELF, p5i);
        GETATTR_P5Interpreter_my_perl(interp, p5i, my_perl);
        GETATTR_P5Scalar_sv(interp, SELF, sv);
        perl5_str = SvPVutf8_nolen(sv);
        return Parrot_str_new(interp, perl5_str, strlen(perl5_str));
    }

/*

=item C<PMC *find_method(STRING *name)>

Hands back something that, when invoked, will try to call the method with
the given name on the given Perl 5 Scalar invocant.

=cut

*/
    VTABLE PMC *find_method(STRING *name) {
        PMC             *result;
        PMC             *p5i;
        PerlInterpreter *my_perl;
        struct sv       *invocant;

        GETATTR_P5Scalar_p5i(interp, SELF, p5i);
        GETATTR_P5Interpreter_my_perl(interp, p5i, my_perl);
        GETATTR_P5Scalar_sv(interp, SELF, invocant);

        result = pmc_new(interp, pmc_type(interp, string_from_literal(interp, "P5Invocation")));
        SETATTR_P5Invocation_p5i(interp, result, p5i);
        SETATTR_P5Invocation_invocant_sv(interp, result, SvREFCNT_inc(invocant));
        SETATTR_P5Invocation_name(interp, result, name);
        
        return result;
    }

/*

=item C<INTVAL can(STRING *name)>

Checks if a class can do a given method.

=cut

*/
    VTABLE INTVAL can(STRING *name) {
        PMC             *p5i;
        PerlInterpreter *my_perl;
        struct sv       *invocant;
        INTVAL           result;
        char            *c_name;

        GETATTR_P5Scalar_p5i(interp, SELF, p5i);
        GETATTR_P5Interpreter_my_perl(interp, p5i, my_perl);
        GETATTR_P5Scalar_sv(interp, SELF, invocant);
        c_name = Parrot_str_to_cstring(interp, name);

        /* If it's not blessed, the answer is "no" right off. */
        if (!sv_isobject(invocant))
            return 0;

        /* Otherwise, try UNIVERSAL::can. */
        {
            dSP;
            ENTER;
            SAVETMPS;
            PUSHMARK(SP);
            XPUSHs(invocant);
            XPUSHs(sv_2mortal(newSVpv(c_name, strlen(c_name))));
            PUTBACK;
            call_pv("UNIVERSAL::can", G_SCALAR);
            SPAGAIN;
            result = POPi;
            PUTBACK;
            FREETMPS;
            LEAVE;
        }

        mem_sys_free(c_name);
        return result;
    }
}
