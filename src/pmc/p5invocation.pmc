/*
Copyright (C) 2009, Jonathan Worthington and friends
$Id$

=head1 NAME

src/pmc/p5invocation.pmc - Perl 5 method invocation helper

=head1 DESCRIPTION

This PMC is used to map the invocation of a Perl 5 method onto the Parrot
invocation model and calling conventions.

=cut

*/

/* Various Perl 5 headers that we need. */
#undef __attribute__
#undef __attribute__noreturn__
#undef __attribute__deprecated__
#undef __attribute__pure__
#undef __attribute__format__
#undef __attribute__nonnull__
#undef __attribute__warn_unused_result__
#undef __attribute__unused__
#define __attribute__(x) /* */
#include <EXTERN.h>
#include <perl.h>

/* Plus need to know about the interpreter and scalar wrapper. */
#include "pmc_p5interpreter.h"
#include "pmc_p5scalar.h"
#include "pmc_p5namespace.h"
#include "parrot/oplib/ops.h"

#include "bkmarshal.h"

pmclass P5Invocation group blizkost_group dynpmc {
    ATTR PMC       *p5i;
    ATTR struct sv *invocant_sv;
    ATTR PMC       *invocant_ns;
    ATTR STRING    *name;

/*

=item C<void init()>

Set up P5Invocation PMC.

=cut

*/

    VTABLE void init() {
        /* Set up the underlying structure. */
        PMC_data(SELF) = mem_allocate_zeroed_typed(Parrot_P5Invocation_attributes);
        PObj_custom_mark_SET(SELF);
        PObj_custom_destroy_SET(SELF);
    }

/*

=item C<void mark()>

Mark GC-ables.

=cut

*/
    VTABLE void mark() {
        if (PMC_data(SELF)) {
            PMC    *p5i, *invocant_ns;
            STRING *name;
            GET_ATTR_p5i(interp, SELF, p5i);
            GET_ATTR_invocant_ns(interp, SELF, invocant_ns);
            GET_ATTR_name(interp, SELF, name);
            if (p5i)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)p5i);
            if (invocant_ns)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)invocant_ns);
            if (name)
                Parrot_gc_mark_PObj_alive(interp, (PObj*)name);
        }
    }

    VTABLE void destroy() {
        /* XXX TODO. */
    }

/*

=item C<void *invoke(void *next)>

Handles the actual invocation.

=cut

*/
    VTABLE opcode_t *invoke(void *next) {
        STRING          *name;
        char            *c_name;
        struct sv       *invocant_sv;
        PMC             *invocant_ns;
        PMC             *p5i, *results;

        PMC *ctx         = CURRENT_CONTEXT(interp);
        PMC *call_object = Parrot_pcc_get_signature(interp, ctx);

        PMC *positional, *named;

        Parrot_pcc_fill_params_from_c_args(interp, call_object, "PsPns",
                &positional, &named);

        /* Get the interpreter, SV and the name. */
        GET_ATTR_p5i(interp, SELF, p5i);
        GET_ATTR_name(interp, SELF, name);
        c_name = Parrot_str_to_cstring(interp, name);
        GET_ATTR_invocant_sv(interp, SELF, invocant_sv);
        GET_ATTR_invocant_ns(interp, SELF, invocant_ns);

        blizkost_call_method(interp, p5i, c_name, invocant_sv, invocant_ns,
                positional, named, &results);

        mem_sys_free(c_name);

        Parrot_pcc_build_call_from_c_args(interp, call_object, "Ps", results);

        return blizkost_return_from_invoke(interp, next);
    }
}
